module Calculator (
    input [1:0] number,         // Two bits for the number (00, 01, 10, 11)
    input sign,                 // Sign bit (0 for negative, 1 for positive)
    input [1:0] operation,      // Two bits for the operation (00 to 11)
    input clock,                // Clock signal (updated by a switch click)
    output reg [6:0] display_input,    // 7-segment display for current input
    output reg [6:0] display_hundreds, // 7-segment display for hundreds place
    output reg [6:0] display_tens,     // 7-segment display for tens place
    output reg [6:0] display_ones,     // 7-segment display for ones place
    output reg div_by_zero_led,        // LED for division by zero flag
    output reg result_zero_led,        // LED for result equals zero flag
    output reg input_negative_led,     // LED for negative input flag
    output reg result_negative_led     // LED for negative result flag
);

// Internal data members
reg [8:0] intermediate_result; // Holds intermediate results (8 bits result + 1 sign bit)
reg [8:0] final_result;        // Holds the final result (8 bits result + 1 sign bit)

// Sequential input tracking
reg [3:0] inputs_count;        // Tracks the number of inputs processed
reg [4:0] current_input;       // Register to store the current input (sign + operation + number)

// Error and flag indicators
reg div_by_zero_flag;          // Flag for division by zero
reg result_zero_flag;          // Flag for zero result
reg result_negative_flag;      // Flag for negative result

// Declare additional variables here
reg [8:0] formatted_number;    // Holds the formatted number (sign + magnitude)
reg [1:0] current_operation;   // Holds the current operation (2 bits)

// Display variables
reg [11:0] bcd_result;                  // Holds BCD result: 12 bits (4 each for hundreds, tens, ones)
reg [3:0] bcd_input;
reg [3:0] bcd_hundreds;
reg [3:0] bcd_tens;
reg [3:0] bcd_ones;
reg [11:0] bcd_input_temp; // Temporary variable to hold the full BCD result


////////////////////////////////////////////////////////////////////

// Adition function
function [8:0] add;
    input [8:0] operand1;
    input [8:0] operand2;
    reg [8:0] op1_converted;
    reg [8:0] op2_converted;
    reg [7:0] temp_result; // Temporary result for the addition
    reg carry;
    integer i;
begin
    // Convert operands to two's complement form if negative
    op1_converted = (operand1[8] == 0) ? twos_complement(operand1) : operand1;
    op2_converted = (operand2[8] == 0) ? twos_complement(operand2) : operand2;

    // Perform addition
    temp_result = 8'b0;
    carry = 0;
    for (i = 0; i < 8; i = i + 1) begin
        temp_result[i] = op1_converted[i] ^ op2_converted[i] ^ carry;
        carry = (op1_converted[i] & op2_converted[i]) | (op1_converted[i] & carry) | (op2_converted[i] & carry);
    end

    // Include the carry bit if it exists
    add[7:0] = temp_result;
    
    if (operand1[7:0] > operand2[7:0])
	add[8] = operand1[8];
    else if (operand1[7:0] < operand2[7:0])
	add[8] = operand2[8];
    else
	add[8] = operand1[8];


    // Reconvert result to sign-magnitude if needed
    if (add[8] == 0) begin
        add = twos_complement(add);
    end
end
endfunction


// Two's Complement function
function [8:0] twos_complement;
    input [8:0] operand;
    reg [7:0] inverted; // Temporary variable for inverted bits
    reg carry;
    integer i;
begin
    inverted = 8'b0;
    carry = 1;
    for (i = 0; i < 8; i = i + 1) begin
        inverted[i] = ~operand[i];
    end
    for (i = 0; i < 8; i = i + 1) begin
        twos_complement[i] = inverted[i] ^ carry;
        carry = inverted[i] & carry;
    end
    twos_complement[8] = operand[8]; // Preserve the original sign bit
end
endfunction


// Binary to BCD Conversion Function
function [11:0] binary_to_bcd; // Converts 8-bit binary to 12-bit BCD (3 digits)
    input [7:0] binary;        // Input binary number (8 bits)
    integer i;
    reg [19:0] shift_register; // 20-bit shift register for BCD conversion
begin
    // Initialize shift register
    shift_register = 20'b0;
    shift_register[7:0] = binary;

    // Perform 8 iterations of the double-dabble algorithm
    for (i = 0; i < 8; i = i + 1) begin
        // Check and adjust each BCD digit
        if (shift_register[11:8] >= 5)
            shift_register[11:8] = shift_register[11:8] + 3;
        if (shift_register[15:12] >= 5)
            shift_register[15:12] = shift_register[15:12] + 3;
        if (shift_register[19:16] >= 5)
            shift_register[19:16] = shift_register[19:16] + 3;

        // Shift left by 1 bit
        shift_register = shift_register << 1;
    end

    // Extract the BCD result
    binary_to_bcd = shift_register[19:8];
end
endfunction

// BCD to 7-Segment Display Conversion Function
function [6:0] bcd_to_7seg; // Converts a 4-bit BCD digit to a 7-segment code
    input [3:0] bcd;         // Input BCD digit
begin
    case (bcd)
        4'b0000: bcd_to_7seg = 7'b1000000; // 0
        4'b0001: bcd_to_7seg = 7'b1111001; // 1
        4'b0010: bcd_to_7seg = 7'b0100100; // 2
        4'b0011: bcd_to_7seg = 7'b0110000; // 3
        4'b0100: bcd_to_7seg = 7'b0011001; // 4
        4'b0101: bcd_to_7seg = 7'b0010010; // 5
        4'b0110: bcd_to_7seg = 7'b0000010; // 6
        4'b0111: bcd_to_7seg = 7'b1111000; // 7
        4'b1000: bcd_to_7seg = 7'b0000000; // 8
        4'b1001: bcd_to_7seg = 7'b0010000; // 9
        default: bcd_to_7seg = 7'b1111111; // Invalid input
    endcase
end
endfunction


////////////////////////////////////////////////////////////////////////

initial begin
    intermediate_result = 9'b100000000; // Initialize to 0 (positive)
    final_result = 9'b100000000;        // Initialize to 0 (positive)
    current_input = 5'b00000;           // Default input (positive 0, addition)
    div_by_zero_led = 0;
    result_zero_led = 0;
    input_negative_led = 0;
    result_negative_led = 0;
    bcd_result = 12'b0;
    bcd_input = 4'b0;
    bcd_hundreds = 4'b0;
    bcd_tens = 4'b0;
    bcd_ones = 4'b0;
    display_input = 7'b1111111;
    display_hundreds = 7'b1111111;
    display_tens = 7'b1111111;
    display_ones = 7'b1111111;
end

always @(posedge clock) begin
    // Capture input: 1 bit sign, 2 bits operation, 2 bits number
    current_input = {sign, operation, number};

    // Format the number with its sign
    formatted_number = {current_input[4], 6'b000000, current_input[1:0]}; // Sign + magnitude (2 bits for number)
    current_operation = current_input[3:2]; // Extract operation

    // Update input display and flags
    display_input = {1'b0, formatted_number[7:0]}; // Display number
    input_negative_led = ~formatted_number[8];    // Check if input is negative

    // Update input BCD and display
    bcd_input_temp = binary_to_bcd(formatted_number[7:0]); // Get the full BCD result
    bcd_input = bcd_input_temp[3:0]; // Extract the ones digit (least significant 4 bits)    display_input = bcd_to_7seg(bcd_input); // Convert BCD to 7-segment

 

    // Perform the operation
    case (current_operation)
        2'b00: intermediate_result = add(intermediate_result, formatted_number); // Addition
        2'b01: intermediate_result = add(intermediate_result, twos_complement(formatted_number)); // Subtraction
        //2'b10: intermediate_result = multiply(intermediate_result, formatted_number); // Multiplication
        //2'b11: begin
        //    if (formatted_number[7:0] == 8'b00000000) begin
        //        div_by_zero_led = 1; // Division by zero detected
        //    end else begin
        //        div_by_zero_led = 0;
        //        intermediate_result = divide(intermediate_result, formatted_number); // Division
        //    end
        //end
    endcase

    // Convert binary result to BCD
    bcd_result = binary_to_bcd(intermediate_result[7:0]);

    // Extract BCD digits
    bcd_hundreds = bcd_result[11:8];
    bcd_tens = bcd_result[7:4];
    bcd_ones = bcd_result[3:0];

    // Convert BCD to 7-segment display codes
    display_hundreds = bcd_to_7seg(bcd_hundreds);
    display_tens = bcd_to_7seg(bcd_tens);
    display_ones = bcd_to_7seg(bcd_ones);

    // Update result flags
    result_zero_led = (intermediate_result[7:0] == 8'b00000000); // Zero result flag
    result_negative_led = ~intermediate_result[8]; // Negative result flag

end


endmodule
